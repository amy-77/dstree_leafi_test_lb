//
// Created by Qitong Wang on 2022/10/11.
// Copyright (c) 2022 Université Paris Cité. All rights reserved.
//

#ifndef DSTREE_SRC_EXEC_STAT_H_
#define DSTREE_SRC_EXEC_STAT_H_

#include <tuple>
#include <cmath>
#include <random>

#include "global.h"

namespace upcite {

// generated by ChatGPT
ID_TYPE get_random_int_in_range(ID_TYPE min, ID_TYPE max_exclusive) {
  // Random number engine (using Mersenne Twister 19937 algorithm)
  std::random_device rd;  // Obtain a random number from hardware
  std::mt19937 eng(rd()); // Seed the generator

  // Define the range
  std::uniform_int_distribution<ID_TYPE> distr(min, max_exclusive - 1);

  return distr(eng); // Generate and return the random number
}

RESPONSE znormalize(VALUE_TYPE *series_in_place, ID_TYPE series_length) {
  VALUE_TYPE mean = 0, std = 0, diff;

  for (ID_TYPE value_i = 0; value_i < series_length; ++value_i) {
    mean += series_in_place[value_i];
  }

  mean /= (VALUE_TYPE) series_length;

  for (ID_TYPE value_i = 0; value_i < series_length; ++value_i) {
    diff = series_in_place[value_i] - mean;
    std += diff * diff;
  }

  std = (VALUE_TYPE) sqrt(std / (VALUE_TYPE) series_length);

  if (std <= constant::EPSILON) {
    return FAILURE;
  }

  for (ID_TYPE value_i = 0; value_i < series_length; ++value_i) {
    series_in_place[value_i] = (series_in_place[value_i] - mean) / std;
  }

  return SUCCESS;
}

static VALUE_TYPE cal_mean(const VALUE_TYPE *series_ptr,
                           ID_TYPE nvalues) {
  VALUE_TYPE mean = 0;

  for (auto i = 0; i < nvalues; ++i) {
    mean += series_ptr[i];
  }
  mean /= static_cast<VALUE_TYPE>(nvalues);

  return mean;
}

static VALUE_TYPE cal_std(const VALUE_TYPE *series_ptr,
                          ID_TYPE nvalues) {
  VALUE_TYPE mean = 0, square_sum = 0;

  for (auto i = 0; i < nvalues; ++i) {
    mean += series_ptr[i];
  }
  mean /= static_cast<VALUE_TYPE>(nvalues);

  for (auto i = 0; i < nvalues; ++i) {
    square_sum += (series_ptr[i] - mean) * (series_ptr[i] - mean);
  }
  square_sum /= static_cast<VALUE_TYPE>(nvalues);

  return sqrt(square_sum);
}

static std::tuple<VALUE_TYPE, VALUE_TYPE> cal_mean_std(const VALUE_TYPE *series_ptr,
                                                       ID_TYPE nvalues) {
  VALUE_TYPE mean = 0, square_sum = 0;

  for (auto i = 0; i < nvalues; ++i) {
    mean += series_ptr[i];
  }
  mean /= static_cast<VALUE_TYPE>(nvalues);

  for (auto i = 0; i < nvalues; ++i) {
    square_sum += (series_ptr[i] - mean) * (series_ptr[i] - mean);
  }
  square_sum /= static_cast<VALUE_TYPE>(nvalues);

  return std::make_tuple(mean, sqrt(square_sum));
}

}

#endif //DSTREE_SRC_EXEC_STAT_H_
